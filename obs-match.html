<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Previous Match Results</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: transparent;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .card {
      width: 480px;
      background: rgba(28,28,28,0.95);
      border-radius: 12px;
      padding: 10px;
      color: #e9eef8;
      text-align: center;
    }

    .title {
      font-size: 28px;
      color: #bcd4ff;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .entry {
      height: 36px;
      line-height: 36px;
      display: flex;
      justify-content: space-between;
      padding: 0 12px;
      font-size: 22px;
      font-weight: 600;
      color: #ffffff;
      border-radius: 6px;
      transition: background 0.3s;
      align-items: center;
      box-sizing: border-box;
    }

    .entry span.place { 
      width: 30px;
      text-align: center;
      color: #bcd4ff;
    }
    .entry span.place.gold { color: #ffd700; }
    .entry span.place.silver { color: #c0c0c0; }
    .entry span.place.bronze { color: #cd7f32; }

    .entry span.name {
      width: 290px;
      text-align: left;
      margin-left: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .entry span.elo { 
      width: 65px;
      text-align: center;
    }

    .entry span.delta {
      width: 65px;
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .delta-arrow {
      font-size: 0.7em;
      margin-right: 3px;
    }

    .entry.highlight { background: rgba(255,255,255,0.15); }
    .delta-positive { color: #4ade80; }
    .delta-negative { color: #f87171; }

    .loading, .error {
      font-size: 16px;
      color: #aab6d9;
    }

    #resultsList {
      opacity: 1;
      transition: opacity 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="title">Previous Match Results</div>
    <div id="resultsList"></div>
  </div>

<script>
  const API_BASE = "https://rapid-haze-012c.nextweekmedia.workers.dev";
  const CLIENT_ID = "DISCORD|1069003073311211601";
  const REFRESH_MS = 15000;

  // How often to refresh snapshot names (ms)
  const SNAPSHOT_TTL_MS = 5 * 60 * 1000;

  const resultsEl = document.getElementById("resultsList");
  const urlParams = new URLSearchParams(window.location.search);
  const PLAYER_ID = urlParams.get("player_id");

  if (!PLAYER_ID) {
    resultsEl.innerHTML = '<div class="error">Missing player_id in URL</div>';
    throw new Error("Missing player_id in URL query");
  }

  let lastMatchHash = "";
  let initialLoad = true;

  // Name cache from /get_leaderboard_snapshot
  let displayNameById = {};
  let lastSnapshotAt = 0;
  let lastSnapshotLeaderboardId = "";

  function setError(msg) {
    resultsEl.innerHTML = `<div class="error">Error: ${msg}</div>`;
    console.error(msg);
  }

  function normalizeEvents(data) {
    if (Array.isArray(data)) return data;
    if (Array.isArray(data?.events)) return data.events;
    if (Array.isArray(data?.matches)) return data.matches;
    return [];
  }

  function pickRatingUpdate(payload) {
    const updates = payload?.rating_updates || [];
    return (
      updates.find(u => u.rating_type === "player_global_all") ||
      updates.find(u => u.rating_type === "player_specific" && u.versus === payload?.match?.versus) ||
      updates[0] ||
      null
    );
  }

  function buildRowsFromEvent(evt) {
    const payload = evt?.payload || {};
    const match = payload?.match || {};
    const teams = match?.teams || [];

    // 1) place + fallback username via teams
    const placeById = {};
    const fallbackNameById = {};
    const participantIds = [];

    for (const t of teams) {
      const place = t?.place;
      for (const pl of (t?.players || [])) {
        const id = String(pl?.user_id ?? "");
        if (!id) continue;
        placeById[id] = place;
        fallbackNameById[id] = pl?.username || fallbackNameById[id] || "Unknown";
        participantIds.push(id);
      }
    }

    // 2) elo + delta via rating_updates affected_entries
    const ru = pickRatingUpdate(payload);
    const ratingsById = {};
    for (const entry of (ru?.affected_entries || [])) {
      const id = String(entry?.user_id ?? "");
      if (!id) continue;
      ratingsById[id] = {
        elo: entry?.rating_after,
        delta: entry?.rating_change,
        username: entry?.username
      };
    }

    // Rows sorted by place
    const rows = participantIds.map(id => {
      const r = ratingsById[id] || {};
      const bestName =
        displayNameById[id] ||
        fallbackNameById[id] ||
        r.username ||
        "Unknown";

      return {
        id,
        place: placeById[id],
        name: bestName,
        elo: r.elo,
        delta: r.delta
      };
    });

    rows.sort((a, b) => {
      const pa = (a.place ?? 9999);
      const pb = (b.place ?? 9999);
      if (pa !== pb) return pa - pb;
      return String(a.name).localeCompare(String(b.name));
    });

    return {
      rows,
      matchId: match?.match_id || "",
      leaderboardId: payload?.leaderboard?.leaderboard_id || "",
      ts: evt?.timestamp || 0
    };
  }

  function hashRows(matchId, rows) {
    return matchId + "|" + rows
      .map(p => `${p.id}:${p.place}:${p.elo}:${p.delta}`)
      .join("|");
  }

  function displayRows(rows) {
    resultsEl.innerHTML = "";

    rows.forEach(player => {
      const eloValue = (player.elo === null || player.elo === undefined) ? "—" : player.elo;
      const deltaValue =
        (player.delta === null || player.delta === undefined || isNaN(player.delta))
          ? "—"
          : Math.abs(player.delta);

      let arrowSpan = "";
      let deltaClass = "";

      if (typeof player.delta === "number") {
        if (player.delta > 0) {
          arrowSpan = '<span class="delta-arrow">▲</span>';
          deltaClass = "delta-positive";
        } else if (player.delta < 0) {
          arrowSpan = '<span class="delta-arrow">▼</span>';
          deltaClass = "delta-negative";
        }
      }

      let placeClass = "";
      if (player.place === 1) placeClass = "gold";
      else if (player.place === 2) placeClass = "silver";
      else if (player.place === 3) placeClass = "bronze";

      const row = document.createElement("div");
      row.className = "entry";
      if (String(player.id) === String(PLAYER_ID)) row.classList.add("highlight");

      row.innerHTML = `
        <span class="place ${placeClass}">${player.place ?? "—"}</span>
        <span class="name">${player.name}</span>
        <span class="elo">${eloValue}</span>
        <span class="delta ${deltaClass}">${arrowSpan}${deltaValue}</span>
      `;

      resultsEl.appendChild(row);
    });
  }

  async function refreshLeaderboardSnapshot(leaderboardId) {
    const now = Date.now();
    const stale =
      (now - lastSnapshotAt) > SNAPSHOT_TTL_MS ||
      String(leaderboardId) !== String(lastSnapshotLeaderboardId);

    if (!leaderboardId || !stale) return;

    const url = API_BASE + "/get_leaderboard_snapshot";
    const resp = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        client_id: CLIENT_ID,
        leaderboard_id: leaderboardId
      })
    });

    if (!resp.ok) throw new Error(`Snapshot HTTP ${resp.status}`);
    const data = await resp.json();

    const players = data?.resolved?.players || {};
    const nextMap = { ...displayNameById };

    for (const [key, profile] of Object.entries(players)) {
      const id = String(profile?.player_id || key);
      const display =
        profile?.display_name ||
        profile?.connection_discord?.username ||
        profile?.username;

      if (id && display) nextMap[id] = display;
    }

    displayNameById = nextMap;
    lastSnapshotAt = now;
    lastSnapshotLeaderboardId = String(leaderboardId);
  }

  async function fetchMatchResults() {
    try {
      const url = new URL(API_BASE + "/get_recent_changes");
      url.searchParams.set("client_id", CLIENT_ID);
      url.searchParams.set("limit", "10");
      url.searchParams.set("_ts", String(Date.now())); // avoid edge-caching weirdness

      const resp = await fetch(url.toString(), { method: "GET" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

      const data = await resp.json();
      const events = normalizeEvents(data);

      const recentEvent = events
        .slice()
        .sort((a, b) => (b.timestamp ?? 0) - (a.timestamp ?? 0))
        .find(evt => {
          const teams = evt?.payload?.match?.teams || [];
          return teams.some(t => (t?.players || []).some(p => String(p?.user_id) === String(PLAYER_ID)));
        });

      if (!recentEvent) {
        resultsEl.innerHTML = '<div class="loading">No recent match found for this player.</div>';
        return;
      }

      const { rows, matchId, leaderboardId } = buildRowsFromEvent(recentEvent);

      // Pull display_name mapping (cached) and rebuild rows if we updated names
      await refreshLeaderboardSnapshot(leaderboardId);
      const rebuilt = buildRowsFromEvent(recentEvent); // rebuild so names use displayNameById

      if (!rebuilt.rows.length) {
        resultsEl.innerHTML = '<div class="loading">No players found in the most recent match.</div>';
        return;
      }

      const currentHash = hashRows(rebuilt.matchId, rebuilt.rows);

      if (initialLoad) {
        initialLoad = false;
        lastMatchHash = currentHash;
        displayRows(rebuilt.rows);
        return;
      }

      if (currentHash !== lastMatchHash) {
        lastMatchHash = currentHash;

        resultsEl.style.opacity = 0;
        setTimeout(() => {
          displayRows(rebuilt.rows);
          requestAnimationFrame(() => (resultsEl.style.opacity = 1));
        }, 300);
      }

    } catch (err) {
      setError(err?.message || String(err));
    }
  }

  fetchMatchResults();
  setInterval(fetchMatchResults, REFRESH_MS);
</script>
</body>
</html>
