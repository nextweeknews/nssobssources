<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Previous Match Results - Rank + Inline Deltas</title>

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: transparent;
      font-family: Inter, system-ui, sans-serif;
      display: flex; justify-content: center; align-items: center;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }
      
    .card {
      width: 1720px;
      background: rgba(15, 23, 42, 1);
      border-radius: 24px;
      padding: 48px 50px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      transition: height 0.4s ease;
      color: #e9eef8;
      box-shadow: 0 32px 32px rgba(0,0,0,0.65);
      box-sizing: border-box;
    }

    .title {
      font-size: 56px;
      color: #c7d7ff;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .035em;
      margin-bottom: 24px;
      text-align: center;
    }

    .header-row,
    .entry {
      display: grid;
      grid-template-columns: 150px 1fr 200px 130px 180px 130px;
      align-items: center;
    }

    .header-row {
      height: 60px;
      margin-bottom: 14px;
      background: rgba(148, 163, 184, 0.12);
      font-size: 24px;
      font-weight: 700;
      text-transform: uppercase;
      color: #9ca3c7;
      border-radius: 12px;
      text-align: center;
    }

    .header-row span:nth-child(2) {
      text-align: left;
      padding-left: 36px;
    }

    .header-row > span {
      border-right: 2px solid rgba(255,255,255,0);
    }

    .header-row > span:last-child {
      border-right: none;
    }

    #resultsList {
      display: flex;
      flex-direction: column;
      gap: 10px;
      opacity: 1;
      transition: opacity .3s ease;
    }

    .entry {
      height: 70px;
      background: rgba(255,255,255,0.07);
      border-radius: 14px;
      font-size: 42px;
      font-weight: 600;
      color: #fff;
      align-items: center;
      transition: background .3s ease, box-shadow .3s ease;
    }

    .place {
      font-size: 42px;
      font-weight: 900;
      text-align: center;
      line-height: 1;
      color: #c7d7ff;
    }

    .player-name {
      font-size: 36px;
      font-weight: 600;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: left;
      padding-left: 36px;
      padding-right: 36px;
    }

    .elo-value, .rank-value {
      font-size: 42px;
      font-weight: 900;
      text-align: center;
      line-height: 1;
    }

    .elo-delta, .rank-delta {
      font-size: 36px;
      text-align: center;
      position: relative;
      animation: pulseDelta 1.8s ease-in-out infinite;
    }

    .delta-arrow {
      margin-right: 4px;
      font-size: 0.6em;
      vertical-align: middle;
      position: relative;
      top: -0.2em;
    }

    .gold { color: #ffd700; }
    .silver { color: #c0c0c0; }
    .bronze { color: #cd7f32; }

    .delta-positive { color: #4ade80; }
    .delta-negative { color: #f87171; }

    .entry > span {
      border-right: 2px solid rgba(255,255,255,0.14);
      right: -1px;
      height: 45px;
      position: relative;
      vertical-align: middle;
    }

    .entry > span:last-child {
      border-right: none;
    }

    .entry.highlight-gold {
      background: rgba(255, 215, 0, 0.28);
      box-shadow: 0 0 18px rgba(255, 215, 0, 0.3);
    }

    .entry.highlight-silver {
      background: rgba(192, 192, 192, 0.28);
      box-shadow: 0 0 18px rgba(192, 192, 192, 0.3);
    }

    .entry.highlight-bronze {
      background: rgba(205, 127, 50, 0.28);
      box-shadow: 0 0 18px rgba(205, 127, 50, 0.3);
    }

    .entry.highlight-default {
      background: rgba(52, 211, 153, 0.30);
      box-shadow: 0 0 18px rgba(16, 185, 129, 0.3);
    }

    .loading, .error {
      font-size: 36px;
      width: 100%;
      text-align: center;
    }

    @keyframes pulseDelta {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1);
        opacity: 0.7;
      }
    }
  </style>
</head>

<body>
<div class="card" id="card">
  <div class="title">Previous Match Results</div>

  <div class="header-row">
    <span>Place</span>
    <span>Player</span>
    <span>Elo</span>
    <span>+/-</span>
    <span>Rank</span>
    <span>+/-</span>
  </div>

  <div id="resultsList">
    <div class="loading">Loading…</div>
  </div>
</div>

<script>
const API_BASE   = "https://rapid-haze-012c.nextweekmedia.workers.dev";
const RECENT_URL = `${API_BASE}/get_recent_changes`;
const SNAP_URL   = `${API_BASE}/get_leaderboard_snapshot`;

const CLIENT_ID = "DISCORD|1069003073311211601";
const REFRESH_MS = 15000;

const cardEl = document.getElementById("card");
const resultsListEl = document.getElementById("resultsList");
const PLAYER_ID = new URLSearchParams(location.search).get("player_id");

let initialLoad = true;

// Global baseline ranks from last processed leaderboard
let previousRanks = {};

// Snapshot for the last fully-processed match of the tracked player
let snapshotMatch = null;
let snapshotMatchHash = "";
let snapshotRanks = {};       // { [id]: rankAfterMatch }
let snapshotRankDeltas = {};  // { [id]: { diff, arrow, class } }

// Latest global match we've baseline'd
let lastGlobalMatchHash = "";

// Latest resolved player profiles (display_name, etc.)
let resolvedPlayersCache = {};
let fallbackNamesCache = {}; // from match teams, as a fallback for names

// Async guard
let requestCounter = 0;
// To avoid unnecessary DOM work
let lastDisplayHash = "";

if (!PLAYER_ID) {
  resultsListEl.innerHTML = "<div class='error'>Missing player_id</div>";
  throw new Error("player_id required");
}

function resizeCard(count) {
  const h = 56 + 24 + 60 + 14 + 48 + 50 + (70 * count) + (10 * (count - 1));
  cardEl.style.height = `${h}px`;
}

function normalizeEvents(data) {
  if (Array.isArray(data)) return data;
  if (Array.isArray(data?.events)) return data.events;
  if (Array.isArray(data?.matches)) return data.matches;
  return [];
}

function pickRatingUpdate(payload) {
  const updates = payload?.rating_updates || [];
  // Keep consistent with the leaderboard baseline/ranks
  return (
    updates.find(u => u.rating_type === "player_global_all") ||
    updates[0] ||
    null
  );
}

function extractParticipantsFromEvent(evt) {
  const payload = evt?.payload || {};
  const match = payload?.match || {};
  const teams = match?.teams || [];

  const placeById = {};
  const fallbackNamesById = {};
  const participantIds = [];

  // Place + fallback usernames from teams
  for (const t of teams) {
    const place = t?.place;
    for (const pl of (t?.players || [])) {
      const id = String(pl?.user_id ?? "");
      if (!id) continue;
      placeById[id] = place;
      fallbackNamesById[id] = pl?.username || fallbackNamesById[id] || "Unknown";
      participantIds.push(id);
    }
  }

  // Elo after + delta from rating_updates (prefer global_all)
  const ru = pickRatingUpdate(payload);
  const ratingById = {};
  for (const entry of (ru?.affected_entries || [])) {
    const id = String(entry?.user_id ?? "");
    if (!id) continue;
    ratingById[id] = {
      elo: entry?.rating_after,
      delta: entry?.rating_change,
      username: entry?.username
    };
  }

  const rows = participantIds.map(id => {
    const r = ratingById[id] || {};
    return {
      id,
      place: placeById[id],
      elo: (r.elo == null ? null : Math.round(r.elo)),
      delta: (r.delta == null ? null : Math.round(r.delta)),
      fallbackName: fallbackNamesById[id] || r.username || "Unknown"
    };
  });

  rows.sort((a, b) => {
    const pa = (a.place ?? 9999);
    const pb = (b.place ?? 9999);
    if (pa !== pb) return pa - pb;
    return String(a.fallbackName).localeCompare(String(b.fallbackName));
  });

  return { rows, fallbackNamesById };
}

function hashEvent(evt) {
  const matchId = evt?.payload?.match?.match_id || "";
  const { rows } = extractParticipantsFromEvent(evt);
  return matchId + "|" + rows.map(r => `${r.id}:${r.place}:${r.elo}:${r.delta}`).join("|");
}

function buildRanksFromLeaderboard(leaderboard) {
  const ranks = {};
  leaderboard
    .map(p => {
      const id = p.team?.[0];
      if (id == null) return null;
      return { id: String(id), elo: p.elo ?? 0 };
    })
    .filter(Boolean)
    .sort((a, b) => (b.elo ?? 0) - (a.elo ?? 0)) // highest elo = rank 1
    .forEach((p, i) => {
      ranks[p.id] = i + 1;
    });
  return ranks;
}

function buildEloMapFromLeaderboard(leaderboard) {
  const map = {};
  (leaderboard || []).forEach(p => {
    const id = p.team?.[0];
    if (id != null) {
      map[String(id)] = p.elo ?? 0;
    }
  });
  return map;
}

/**
 * Returns true if the leaderboard we fetched reflects the "after" Elo state for this event
 * (±1 tolerance), i.e., it's safe to advance baseline to this snapshot.
 */
function isLeaderboardSyncedForEvent(evt, leaderboardElos) {
  if (!evt || !leaderboardElos) return false;

  const { rows: participants } = extractParticipantsFromEvent(evt);

  return participants.every(p => {
    const idKey = String(p.id);
    const lbElo = leaderboardElos[idKey];
    const matchElo = Math.round(p.elo ?? 0);

    if (typeof lbElo !== "number") return false;
    return Math.abs(Math.round(lbElo) - matchElo) <= 1;
  });
}

function displaySnapshot(players) {
  if (!snapshotMatch) {
    resultsListEl.innerHTML = "<div class='loading'>No match</div>";
    resizeCard(1);
    return;
  }

  const rows = snapshotMatch.ratingResults[0].newRatings.slice(0, 8);
  resultsListEl.innerHTML = "";

  const showRankDelta = rows.some(p => {
    const d = snapshotRankDeltas[String(p.id)];
    return d && d.diff !== 0;
  });

  rows.forEach(p => {
    const row = document.createElement("div");
    row.className = "entry";

    const idKey = String(p.id);

    if (idKey === String(PLAYER_ID)) {
      if (p.place === 1) row.classList.add("highlight-gold");
      else if (p.place === 2) row.classList.add("highlight-silver");
      else if (p.place === 3) row.classList.add("highlight-bronze");
      else row.classList.add("highlight-default");
    }

    const placeClass =
      p.place === 1 ? "gold" :
      p.place === 2 ? "silver" :
      p.place === 3 ? "bronze" :
      "";

    // Prefer display_name from snapshot resolved.players; fall back to team username
    const name =
      resolvedPlayersCache[idKey]?.display_name ||
      players[idKey]?.display_name ||
      fallbackNamesCache[idKey] ||
      "Unknown";

    const elo = Math.round(p.elo ?? 0);
    const eloDisplay = elo === 0 ? "-" : elo; // 0 Elo → "-"
    const delta = Math.round(p.delta ?? 0);

    const dC = delta > 0 ? "delta-positive" : delta < 0 ? "delta-negative" : "";
    const eloDeltaHTML = delta !== 0 ? `
      <span class="elo-delta ${dC}">
        <span class="delta-arrow">${delta > 0 ? "▲" : "▼"}</span>${Math.abs(delta)}
      </span>` : `<span></span>`;

    const frozenRank = snapshotRanks[idKey];
    const rankValue = typeof frozenRank === "number" ? frozenRank : "—";

    const rd = snapshotRankDeltas[idKey] || null;
    const rankDeltaHTML = (showRankDelta && rd && rd.diff !== 0) ? `
      <span class="rank-delta ${rd.class}">
        <span class="delta-arrow">${rd.arrow}</span>${Math.abs(Math.round(rd.diff))}
      </span>` : `<span></span>`;

    row.innerHTML = `
      <span class="place ${placeClass}">${p.place}</span>
      <span class="player-name">${name}</span>

      <span class="elo-value">${eloDisplay}</span>
      ${eloDeltaHTML}

      <span class="rank-value">${rankValue}</span>
      ${rankDeltaHTML}
    `;

    resultsListEl.appendChild(row);
  });

  resizeCard(rows.length);
}

async function fetchSnapshot(leaderboardId) {
  const body = {
    client_id: CLIENT_ID,

    // Prefer the actual leaderboard_id coming from recent changes ("Season_10" in your snippet)
    leaderboard_id: leaderboardId,

    // Keep compatibility with older naming patterns too
    leaderboard: (leaderboardId || "").toLowerCase(),

    // Keep rank baseline consistent with Elo/delta source
    rating_type: "player_global_all"
  };

  const resp = await fetch(SNAP_URL, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify(body)
  });

  if (!resp.ok) throw new Error(`Snapshot HTTP ${resp.status}`);
  const data = await resp.json();

  // resolved.players -> display_name mapping
  resolvedPlayersCache = data?.resolved?.players || resolvedPlayersCache || {};

  // leaderboard array location can vary; tolerate a couple shapes
  const leaderboard =
    data?.leaderboard ||
    data?.payload?.leaderboard ||
    data?.snapshot?.leaderboard ||
    data?.data?.leaderboard ||
    [];

  return { leaderboard };
}

async function fetchData() {
  const myRequestId = ++requestCounter;

  try {
    // 1) Poll recent changes every 15s
    const recentUrl = new URL(RECENT_URL);
    recentUrl.searchParams.set("client_id", CLIENT_ID);
    recentUrl.searchParams.set("limit", "10");
    recentUrl.searchParams.set("_ts", String(Date.now())); // avoid edge cache stickiness

    const recentResp = await fetch(recentUrl.toString(), { method: "GET" });
    if (!recentResp.ok) throw new Error(`Recent HTTP ${recentResp.status}`);
    const recentData = await recentResp.json();
    if (myRequestId !== requestCounter) return;

    const events = normalizeEvents(recentData)
      .filter(e => e?.payload?.match && e?.payload?.rating_updates);

    const sortedEvents = [...events].sort((a, b) => (b.timestamp ?? 0) - (a.timestamp ?? 0));

    const globalLatest = sortedEvents[0] || null;
    const globalLatestHash = globalLatest ? hashEvent(globalLatest) : null;

    const latestEventForPlayer = sortedEvents.find(evt => {
      const teams = evt?.payload?.match?.teams || [];
      return teams.some(t => (t?.players || []).some(p => String(p?.user_id) === String(PLAYER_ID)));
    }) || null;

    const latestPlayerHash = latestEventForPlayer ? hashEvent(latestEventForPlayer) : null;

    const hasSnapshot = !!snapshotMatch;

    const haveNewGlobalMatch =
      globalLatestHash && globalLatestHash !== lastGlobalMatchHash;

    const playerHasNewerMatchThanSnapshot =
      latestEventForPlayer &&
      (!hasSnapshot || latestPlayerHash !== snapshotMatchHash);

    // Need leaderboard snapshot:
    // - first baseline
    // - any new global match (baseline may move)
    // - player has a new match to snapshot (need synced leaderboard to freeze ranks)
    const needInitialBaseline = Object.keys(previousRanks).length === 0;
    const needSnapshot =
      needInitialBaseline || haveNewGlobalMatch || playerHasNewerMatchThanSnapshot;

    let currentRanks = null;
    let leaderboardElos = null;

    // Choose leaderboard_id from newest available event
    const inferredLeaderboardId =
      latestEventForPlayer?.payload?.leaderboard?.leaderboard_id ||
      globalLatest?.payload?.leaderboard?.leaderboard_id ||
      "Season_10";

    if (needSnapshot) {
      const snap = await fetchSnapshot(inferredLeaderboardId);
      if (myRequestId !== requestCounter) return;

      const leaderboard = snap.leaderboard || [];
      currentRanks = buildRanksFromLeaderboard(leaderboard);
      leaderboardElos = buildEloMapFromLeaderboard(leaderboard);

      // Freeze "before" baseline for THIS poll (prevents mid-function mutation issues)
      const baselineRanks = previousRanks; // or: { ...previousRanks }

      // Determine if the fetched leaderboard is synced to the newest global match
      const globalLatestSynced =
        globalLatest && isLeaderboardSyncedForEvent(globalLatest, leaderboardElos);

      // (A) Initialize baseline if we didn't have one yet
      if (needInitialBaseline && Object.keys(currentRanks).length > 0) {
        previousRanks = currentRanks;
        if (globalLatestHash) lastGlobalMatchHash = globalLatestHash;
      }

      // (B) If player has a newer match than snapshot, try to process it
      if (latestEventForPlayer && playerHasNewerMatchThanSnapshot) {
        const { rows: participants, fallbackNamesById } = extractParticipantsFromEvent(latestEventForPlayer);

        // Cache fallback names (team usernames) for display fallback
        fallbackNamesCache = fallbackNamesById || fallbackNamesCache;

        // Check Elo sync (±1 tolerance) against current leaderboard
        const leaderboardSyncedForPlayerMatch = participants.every(p => {
          const idKey = String(p.id);
          const lbElo = leaderboardElos ? leaderboardElos[idKey] : undefined;
          const matchElo = Math.round(p.elo ?? 0);
          if (typeof lbElo !== "number") return false;
          return Math.abs(Math.round(lbElo) - matchElo) <= 1;
        });

        if (leaderboardSyncedForPlayerMatch) {
          const newSnapshotRanks = {};
          const newSnapshotRankDeltas = {};

          participants.forEach(p => {
            const idKey = String(p.id);
            const afterRank = currentRanks ? currentRanks[idKey] : undefined;

            if (typeof afterRank === "number") {
              newSnapshotRanks[idKey] = afterRank;
            }

            // IMPORTANT: compare to the frozen baseline, not the mutable previousRanks
            const beforeRank = baselineRanks[idKey];

            let diff = 0;
            let arrow = "";
            let cls = "";

            if (typeof beforeRank === "number" && typeof afterRank === "number") {
              diff = beforeRank - afterRank; // positive = improved rank
              if (diff > 0) {
                arrow = "▲";
                cls = "delta-positive";
              } else if (diff < 0) {
                arrow = "▼";
                cls = "delta-negative";
              }
            }

            newSnapshotRankDeltas[idKey] = { diff, arrow, class: cls };
          });

          // Store snapshot in the same shape your renderer expects
          snapshotMatch = {
            ratingResults: [
              {
                newRatings: participants.map(p => ({
                  id: p.id,
                  place: p.place,
                  elo: p.elo,
                  delta: p.delta
                }))
              }
            ]
          };

          snapshotMatchHash = latestPlayerHash;
          snapshotRanks = newSnapshotRanks;
          snapshotRankDeltas = newSnapshotRankDeltas;

          // NOTE: Do NOT advance previousRanks here.
          // We advance baseline only when the newest GLOBAL match is confirmed synced,
          // so deltas remain incremental and we don't skip states.
        }
        // If not synced, snapshot stays as-is; try again next poll.
      }

      // (C) Advance rolling baseline exactly one step when we KNOW the leaderboard reflects the new global state
      if (haveNewGlobalMatch && globalLatestSynced) {
        previousRanks = currentRanks;
        lastGlobalMatchHash = globalLatestHash;
      }
    }

    // Build display hash from snapshot state
    let displayHash;
    if (!snapshotMatch) {
      displayHash = "NO_MATCH";
    } else {
      const rows = snapshotMatch.ratingResults[0].newRatings.slice(0, 8);
      const parts = rows.map(p => {
        const idKey = String(p.id);
        const elo = Math.round(p.elo ?? 0);
        const delta = Math.round(p.delta ?? 0);
        const rankSnapshot = snapshotRanks[idKey];
        const rankDisplayed = typeof rankSnapshot === "number" ? rankSnapshot : "—";
        const rd = snapshotRankDeltas[idKey]?.diff ?? 0;
        return `${idKey}:${p.place}:${elo}:${delta}:${rankDisplayed}:${rd}`;
      });
      displayHash = parts.join("|");
    }

    if (!initialLoad && displayHash === lastDisplayHash) {
      return;
    }

    lastDisplayHash = displayHash;
    initialLoad = false;

    resultsListEl.style.opacity = 0;
    setTimeout(() => {
      if (myRequestId !== requestCounter) return;

      // For backward compatibility: pass a players map (we now prefer resolvedPlayersCache anyway)
      const playersForRenderer = resolvedPlayersCache || {};
      displaySnapshot(playersForRenderer);

      requestAnimationFrame(() => (resultsListEl.style.opacity = 1));
    }, 300);

  } catch (err) {
    if (myRequestId !== requestCounter) return;
    resultsListEl.innerHTML = `<div class="error">${err.message}</div>`;
  }
}

async function poll() {
  await fetchData();
  setTimeout(poll, REFRESH_MS);
}

poll();
</script>

</body>
</html>
