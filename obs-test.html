<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Previous Match Results - Rank + Inline Deltas</title>

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: transparent;
      font-family: Inter, system-ui, sans-serif;
      display: flex; justify-content: center; align-items: center;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }
      
    .card {
      width: 1720px;
      background: rgba(15, 23, 42, 1);
      border-radius: 24px;
      padding: 48px 50px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      transition: height 0.4s ease;
      color: #e9eef8;
      box-shadow: 0 32px 32px rgba(0,0,0,0.65);
      box-sizing: border-box;
    }

    .title {
      font-size: 56px;
      color: #c7d7ff;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .035em;
      margin-bottom: 24px;
      text-align: center;
    }

    .header-row,
    .entry {
      display: grid;
      grid-template-columns: 150px 1fr 200px 130px 180px 130px;
      align-items: center;
    }

    .header-row {
      height: 60px;
      margin-bottom: 14px;
      background: rgba(148, 163, 184, 0.12);
      font-size: 24px;
      font-weight: 700;
      text-transform: uppercase;
      color: #9ca3c7;
      border-radius: 12px;
      text-align: center;
    }

    .header-row span:nth-child(2) {
      text-align: left;
      padding-left: 36px;
    }

    .header-row > span {
      border-right: 2px solid rgba(255,255,255,0);
    }

    .header-row > span:last-child {
      border-right: none;
    }

    #resultsList {
      display: flex;
      flex-direction: column;
      gap: 10px;
      opacity: 1;
      transition: opacity .3s ease;
    }

    .entry {
      height: 70px;
      background: rgba(255,255,255,0.07);
      border-radius: 14px;
      font-size: 42px;
      font-weight: 600;
      color: #fff;
      align-items: center;
      transition: background .3s ease, box-shadow .3s ease;
    }

    .place {
      font-size: 42px;
      font-weight: 900;
      text-align: center;
      line-height: 1;
      color: #c7d7ff;
    }

    .player-name {
      font-size: 36px;
      font-weight: 600;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: left;
      padding-left: 36px;
      padding-right: 36px;
    }

    .elo-value, .rank-value {
      font-size: 42px;
      font-weight: 900;
      text-align: center;
      line-height: 1;
    }

    .elo-delta, .rank-delta {
      font-size: 36px;
      text-align: center;
      position: relative;
    }

    .delta-arrow {
      margin-right: 4px;
      font-size: 0.6em;
      vertical-align: middle;
      position: relative;
      top: -0.2em;
    }

    .gold { color: #ffd700; }
    .silver { color: #c0c0c0; }
    .bronze { color: #cd7f32; }

    .delta-positive { color: #4ade80; }
    .delta-negative { color: #f87171; }

    .entry > span {
      border-right: 2px solid rgba(255,255,255,0.14);
      right: -1px;
      height: 45px;
      position: relative;
      vertical-align: middle;
    }

    .entry > span:last-child {
      border-right: none;
    }

    .entry.highlight-gold {
      background: rgba(255, 215, 0, 0.28);
      box-shadow: 0 0 18px rgba(255, 215, 0, 0.3);
    }

    .entry.highlight-silver {
      background: rgba(192, 192, 192, 0.28);
      box-shadow: 0 0 18px rgba(192, 192, 192, 0.3);
    }

    .entry.highlight-bronze {
      background: rgba(205, 127, 50, 0.28);
      box-shadow: 0 0 18px rgba(205, 127, 50, 0.3);
    }

    .entry.highlight-default {
      background: rgba(52, 211, 153, 0.30);
      box-shadow: 0 0 18px rgba(16, 185, 129, 0.3);
    }

    .loading, .error {
      font-size: 36px;
      width: 100%;
      text-align: center;
    }

  </style>
</head>

<body>
<div class="card" id="card">
  <div class="title">Previous Match Results</div>

  <div class="header-row">
    <span>Place</span>
    <span>Player</span>
    <span>Elo</span>
    <span>+/-</span>
    <span>Rank</span>
    <span>+/-</span>
  </div>

  <div id="resultsList">
    <div class="loading">Loading…</div>
  </div>
</div>

<script>
const API_URL = "https://rapid-haze-012c.nextweekmedia.workers.dev/get_rating_history";
const LB_URL  = "https://rapid-haze-012c.nextweekmedia.workers.dev/get_leaderboard";
const CLIENT_ID = "DISCORD|1069003073311211601";
const REFRESH_MS = 15000;

const cardEl = document.getElementById("card");
const resultsListEl = document.getElementById("resultsList");
const PLAYER_ID = new URLSearchParams(location.search).get("player_id");

let initialLoad = true;

// Global baseline ranks snapshot from the last processed leaderboard
let previousRanks = {};

// Frozen snapshot for the last fully-processed match of the tracked player
let snapshotMatch = null;
let snapshotMatchHash = "";
let snapshotRanks = {};       // { [id]: rankAfterMatch }
let snapshotRankDeltas = {};  // { [id]: { diff, arrow, class } }

// Latest global match we've seen (from rating history)
let lastGlobalMatchHash = "";

// Request guard
let requestCounter = 0;
// Display hash to avoid unnecessary DOM work + animations
let lastDisplayHash = "";

if (!PLAYER_ID) {
  resultsListEl.innerHTML = "<div class='error'>Missing player_id</div>";
  throw new Error("player_id required");
}

function resizeCard(count) {
  const h = 56 + 24 + 60 + 14 + 48 + 50 + (70 * count) + (10 * (count - 1));
  cardEl.style.height = `${h}px`;
}

function hashMatch(match) {
  return match.ratingResults[0].newRatings
    .map(p => `${p.id}:${p.place}:${p.elo}:${p.delta}`)
    .join("|");
}

function buildRanksFromLeaderboard(leaderboard) {
  const ranks = {};
  leaderboard
    .map(p => {
      const id = p.team?.[0];
      if (id == null) return null;
      return { id: String(id), elo: p.elo ?? 0 };
    })
    .filter(Boolean)
    .sort((a, b) => (b.elo ?? 0) - (a.elo ?? 0)) // highest elo = rank 1
    .forEach((p, i) => {
      ranks[p.id] = i + 1;
    });
  return ranks;
}

function buildEloMapFromLeaderboard(leaderboard) {
  const map = {};
  (leaderboard || []).forEach(p => {
    const id = p.team?.[0];
    if (id != null) {
      map[String(id)] = p.elo ?? 0;
    }
  });
  return map;
}

function displaySnapshot(players) {
  if (!snapshotMatch) {
    resultsListEl.innerHTML = "<div class='loading'>No match</div>";
    resizeCard(1);
    return;
  }

  const rows = snapshotMatch.ratingResults[0].newRatings.slice(0, 8);
  resultsListEl.innerHTML = "";

  const showRankDelta = rows.some(p => {
    const d = snapshotRankDeltas[String(p.id)];
    return d && d.diff !== 0;
  });

  rows.forEach(p => {
    const row = document.createElement("div");
    row.className = "entry";

    const idKey = String(p.id);

    if (idKey === String(PLAYER_ID)) {
      if (p.place === 1) row.classList.add("highlight-gold");
      else if (p.place === 2) row.classList.add("highlight-silver");
      else if (p.place === 3) row.classList.add("highlight-bronze");
      else row.classList.add("highlight-default");
    }

    const placeClass =
      p.place === 1 ? "gold" :
      p.place === 2 ? "silver" :
      p.place === 3 ? "bronze" :
      "";

    const name = players[p.id]?.display_name || "Unknown";

    const elo = Math.round(p.elo ?? 0);
    const delta = Math.round(p.delta ?? 0);

    const dC = delta > 0 ? "delta-positive" : delta < 0 ? "delta-negative" : "";
    const eloDeltaHTML = delta !== 0 ? `
      <span class="elo-delta ${dC}">
        <span class="delta-arrow">${delta > 0 ? "▲" : "▼"}</span>${Math.abs(delta)}
      </span>` : `<span></span>`;

    const frozenRank = snapshotRanks[idKey];
    const rankValue = typeof frozenRank === "number" ? frozenRank : "—";

    const rd = snapshotRankDeltas[idKey] || null;
    const rankDeltaHTML = (showRankDelta && rd && rd.diff !== 0) ? `
      <span class="rank-delta ${rd.class}">
        <span class="delta-arrow">${rd.arrow}</span>${Math.abs(Math.round(rd.diff))}
      </span>` : `<span></span>`;

    row.innerHTML = `
      <span class="place ${placeClass}">${p.place}</span>
      <span class="player-name">${name}</span>

      <span class="elo-value">${elo}</span>
      ${eloDeltaHTML}

      <span class="rank-value">${rankValue}</span>
      ${rankDeltaHTML}
    `;

    resultsListEl.appendChild(row);
  });

  resizeCard(rows.length);
}

async function fetchData() {
  const myRequestId = ++requestCounter;

  try {
    // --- Poll rating history every 15s ---
    const historyResp = await fetch(API_URL, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
        player_id: PLAYER_ID,
        client_id: CLIENT_ID,
        limit: 10
      })
    });
    const historyData = await historyResp.json();
    if (myRequestId !== requestCounter) return;

    const players = historyData.resolved?.players || {};
    const matches = historyData.matches || [];

    // Sort matches newest → oldest
    const sortedMatches = [...matches].sort((a, b) => b.ts - a.ts);

    const globalLatest = sortedMatches[0] || null;
    const globalLatestHash = globalLatest ? hashMatch(globalLatest) : null;

    const latestMatchForPlayer = sortedMatches.find(m =>
      m.ratingResults.some(r =>
        r.newRatings.some(p => String(p.id) === String(PLAYER_ID))
      )
    );

    const latestMatchHash = latestMatchForPlayer
      ? hashMatch(latestMatchForPlayer)
      : null;

    const hasSnapshot = !!snapshotMatch;

    const playerHasNewerMatchThanSnapshot =
      latestMatchForPlayer &&
      (!hasSnapshot || latestMatchHash !== snapshotMatchHash);

    const haveNewGlobalMatch =
      globalLatest && globalLatestHash !== lastGlobalMatchHash;

    const globalLatestInvolvesPlayer = globalLatest
      ? globalLatest.ratingResults.some(r =>
          r.newRatings.some(p => String(p.id) === String(PLAYER_ID))
        )
      : false;

    // We need leaderboard when:
    // - there is any new global match, OR
    // - the player has a newer match than our snapshot (to keep checking for sync)
    const needLeaderboard = haveNewGlobalMatch || playerHasNewerMatchThanSnapshot;

    if (needLeaderboard) {
      const lbResp = await fetch(LB_URL, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          leaderboard: "season_10",
          rating_type: "player_global_all",
          client_id: CLIENT_ID
        })
      });
      const lbData = await lbResp.json();
      if (myRequestId !== requestCounter) return;

      const leaderboard = lbData.leaderboard || [];
      const currentRanks = buildRanksFromLeaderboard(leaderboard);
      const leaderboardElos = buildEloMapFromLeaderboard(leaderboard);

      const isInitialBaseline = Object.keys(previousRanks).length === 0;

      // If we have a player match newer than our snapshot, see if we can
      // update the snapshot (Checkpoint 2 & 3).
      if (latestMatchForPlayer && playerHasNewerMatchThanSnapshot) {
        const participants = latestMatchForPlayer.ratingResults[0].newRatings;

        // Check if leaderboard Elo is in sync with match Elo (±1 tolerance)
        const leaderboardSynced = participants.every(p => {
          const idKey = String(p.id);
          const lbElo = leaderboardElos[idKey];
          const matchElo = Math.round(p.elo ?? 0);
          if (typeof lbElo !== "number") return false;
          return Math.abs(Math.round(lbElo) - matchElo) <= 1;
        });

        if (leaderboardSynced) {
          const newSnapshotRanks = {};
          const newSnapshotRankDeltas = {};

          participants.forEach(p => {
            const idKey = String(p.id);
            const afterRank = currentRanks[idKey];

            if (typeof afterRank === "number") {
              newSnapshotRanks[idKey] = afterRank;
            }

            const beforeRank = previousRanks[idKey];

            let diff = 0;
            let arrow = "";
            let cls = "";

            // On very first baseline, or if we don't know their prior rank,
            // we treat delta as 0 (we can't know true previous rank).
            if (!isInitialBaseline && typeof beforeRank === "number" && typeof afterRank === "number") {
              diff = beforeRank - afterRank; // positive = improved
              if (diff > 0) {
                arrow = "▲";
                cls = "delta-positive";
              } else if (diff < 0) {
                arrow = "▼";
                cls = "delta-negative";
              }
            }

            newSnapshotRankDeltas[idKey] = { diff, arrow, class: cls };
          });

          snapshotMatch = latestMatchForPlayer;
          snapshotMatchHash = latestMatchHash;
          snapshotRanks = newSnapshotRanks;
          snapshotRankDeltas = newSnapshotRankDeltas;

          // After processing this match, our new baseline is the current leaderboard
          previousRanks = currentRanks;
        }
        // If not synced yet: we keep the old snapshot and baseline; next poll
        // will keep hitting leaderboard due to playerHasNewerMatchThanSnapshot.
      }

      // Initialize baseline if it's the first time we ever saw leaderboard
      if (isInitialBaseline && Object.keys(currentRanks).length > 0) {
        previousRanks = currentRanks;
      }

      // For any new global match that does NOT involve the tracked player,
      // we advance the global baseline so later deltas reflect exactly one match.
      if (haveNewGlobalMatch && !globalLatestInvolvesPlayer) {
        previousRanks = currentRanks;
      }

      // Mark that we've processed up to this global match in rating-history space
      if (haveNewGlobalMatch && globalLatestHash) {
        lastGlobalMatchHash = globalLatestHash;
      }
    }

    // At this point, snapshotMatch / snapshotRanks / snapshotRankDeltas represent
    // the last fully-processed match for the tracked player.
    // Build display hash from snapshot state.
    let displayHash;

    if (!snapshotMatch) {
      displayHash = "NO_MATCH";
    } else {
      const rows = snapshotMatch.ratingResults[0].newRatings.slice(0, 8);
      const parts = rows.map(p => {
        const idKey = String(p.id);
        const elo = Math.round(p.elo ?? 0);
        const delta = Math.round(p.delta ?? 0);
        const rankSnapshot = snapshotRanks[idKey];
        const rankDisplayed = typeof rankSnapshot === "number"
          ? rankSnapshot
          : "—";
        const rd = snapshotRankDeltas[idKey]?.diff ?? 0;
        return `${idKey}:${p.place}:${elo}:${delta}:${rankDisplayed}:${rd}`;
      });
      displayHash = parts.join("|");
    }

    if (!initialLoad && displayHash === lastDisplayHash) {
      return;
    }

    lastDisplayHash = displayHash;
    initialLoad = false;

    resultsListEl.style.opacity = 0;
    setTimeout(() => {
      if (myRequestId !== requestCounter) return;

      displaySnapshot(players);

      requestAnimationFrame(() => (resultsListEl.style.opacity = 1));
    }, 300);

  } catch (err) {
    if (myRequestId !== requestCounter) return;
    resultsListEl.innerHTML = `<div class="error">${err.message}</div>`;
  }
}

async function poll() {
  await fetchData();
  setTimeout(poll, REFRESH_MS);
}

poll();
</script>
</body>
</html>
